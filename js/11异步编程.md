<h1 align="center"><font color = 'red'>11.1 异步编程</font></h1>
<h3 align="center"></h3>

<h3><font color = "blue">11.1.1 同步和异步</font></h3>



Javascript 这种单线程事件循环模型中，是核心机制。异步行为是为了优化因计算量大而时间长的操作

同步行为对应内存中顺序执行的处理器指令

```javascript
/**
这两行 Javascript 代码对应的低级指令（从 Javascript 到 x86) 并不难想象。

首先，操作系统会在栈内存上分配一个存储浮点数值的空间，然后针对这个值做一次数学计算，再把计算结果写回之前分配的内存中。

所有这些指令都是在单个线程中按顺序执行的。在低级指令的层面，有充足的工具可以确定系统状态。
**/
let x = 3;
x = x + 4;
```

相对地，异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）如果代码要访问些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。

异步操作的例子可以是在定时回调中执行一次简单的数学计算

```javascript
/**
这段程序最终与同步代码执行的任务一样，都是把两个数加在一起，但这一次执行线程不知道 x 值何时会改变，因为这取决于回调何时从消息队列出列并执行。
**/
let x = 3;
setTimeout(() => x = x + 4, 1000);
```

异步代码不容易推断。虽然这个例子对应的低级代码最终跟前面的例子没什么区别，但第二个指令块（加操作及赋值操作）是由系统计时器触发的，这会生成一个入队执行的中断。到底什么时候会触发这个中断，这对 Javascript 运行时来说是一个黑盒，因此实际上无法预知（尽管可以保证这发生在当前线程的同步代码执行之后，否则回调都没有机会出列被执行）。无论如何，在排定回调以后基本没办法知道系统状态何时变化。

为了让后续代码能够使用 x，异步执行的函数需要在更新 x 的值以后通知其他代码。如果程序不需要这个值，那么就只管继续执行，不必等待这个结果了。

设计一个能够知道 x 什么时候可以读取的系统是非常难的。Javascript 在实现这样一个系统的过程中也经历了几次迭代。



<h3><font color = "blue"><b>11.1.2 以往的异步编程模式</b></font></h3>

以前的是不理想的，早期只支持回调函数来表明异步操作完成。串联多个异步操作经常会出现“Callback Hell”

```javascript
/*
关键要理解为什么它是一个异步函数。
settimeout 可以定义一个在指定时间之后会被调度执行的回调函数。
对这个例子而言，1000 毫秒之后，Javascript 运行时会把回调函数推到自己的消息队列上去等待执行。
推到队列之后，回调什么时候出列被执行对 Javascript 代码就完全不可见了。
还有一点，double（）函数在 settimeout 成功调度异步操作之后会立即退出。
*/
function double(value) {
    setTimeout(() => setTimeout(console.log, 0, value * 2), 1000);
}

double(3);
```

##### 1. 异步返回值

```javascript
function double(value, callback) {
    setTimeout(() => callback(value * 2), 1000);
    //这里的 settimeout 调用告诉 Javascript 运行时在 1000 毫秒之后把一个函数推到消息队列上。这个函数会由运行时负责异步调度执行。而位于函数闭包中的回调及其参数在异步执行时仍然是可用的。
}

double(3, (x) => console.log(`I was given: ${x}`));
```

##### 2. 失败处理

```javascript
// 异步操作的失败处理在回调模型中也要考虑，因此自然就出现了成功回调和失败回调
// 这种模式已经不可取了，因为必须在初始化异步操作时定义回调。异步函数的返回值只在短时间内存在，只有预备好将这个短时间内存在的值作为参数的回调才能接收到它。
function double(value, success, failure) {
    setTimeout(() => {
        try {
            if (typeof value !== 'number') {
                throw 'Must provide number as first argument';
            }
        } catch (e) {
            failure(e);
        }
    }, 1000);
}

const successCallBack = (x) => console.log(`Success: ${x}`);
const failureCallBack = (x) => console.log(`Failure: ${x}`);

double(3, successCallBack, failureCallBack);
double('b', successCallBack, failureCallBack)
```

##### 3. 嵌套异步回调

```javascript
// 随着代码规模扩大，回调地狱出现
function double(value, success, failure) {
    setTimeout(() => {
        try {
            if (typeof value !== 'number') {
                throw 'Must provide number as first arguments';
            }
            success(2 * value);
        } catch (e) {
            failure(e);
        }
    }, 1000);
}

const successCallback = (x) => {
    double (x, (y) => console.log(`Success: ${x}`));
};
const failureCallback = (e) => console.log(`Failure:${e}`);

double(3, successCallback, failureCallback)
```

##### 

<h1 align="center"><font color = 'red'>11.2 期约</font></h1>
<h3 align="center"></h3>

期约是对尚不存在结果的一个替身。描述的是一种异步程序执行的机制。

<h3><font color = "blue">11.2.1 Promises/A+规范</font></h3>

<h3><font color = "blue">11.2.2 期约基础</font></h3>

##### 实例化

ECMASCRIPT6 新增的引用类型 Promise，可以通过 new 操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数（后面马上会介绍），下面的例子使用了一个空函数对象来应付一下解释器

```javascript
let p = new Promise(() => {});
setTimeout(console.log, 0, p); // Promise <pending>

// 之所以说是应付解释器，是因为如果不提供执行器函数，就会抛出 Syntaxerror。
```



<h5><font color = "green">1.期约状态机</font></h5>

在把一个期约实例传给 conso1e.log（）时，控制台输出（可能因浏览器不同而略有差异）表明该实例处于待定（pending）状态。

如前所述，期约是一个有状态的对象，可能处于如下 3 种状态之

- 待定（pending)
- 兑现（fulfilled，有时候也称为“解决”，resolved）
- 拒绝（rejected)

###### 解释：

```
待定（pending）是期约的最初始状态。

在待定状态下，期约可以落定（settled）为代表成功的兑现（fulfilled）状态，或者代表失败的拒绝（rejected）状态。

无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。

而且，也不能保证期约必然会脱离待定状态。因此，组织合理的代码无论期约解决（resolve）还是拒绝（reject），甚至永远处于待定（pending）状态，都应该具有恰当的行为。
```

重要的是，期约的状态是私有的，不能直接通过 Javascript 检测到。

> 这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。

另外，期约的状态也不能被外部 Javascript 代码修改。

> 这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。



<h5><font color = "green">2.解决值、拒绝理由及期约用例</font></h5>

期约主要有两大用途。

首先是抽象地表示一个异步操作。

> 期约的状态代表期约是否完成。
>
> “待定”表示尚未开始或者正在执行中
>
> “兑现”表示已经成功完成
>
> “拒绝”则表示没有成功完成

某些情况下，这个状态机就是期约可以提供的最有用的信息。知道一段异步代码已经完成，对于其他代码而言已经足够了。

```
比如，假设期约要向服务器发送一个 HTTP 请求。请求返回 200~299 范围内的状态码就足以让期约的状态变为“兑现”。类似地，如果请求返回的状态码不在 200~299 这个范围内么就会把期约状态切换为“拒绝”。
```

在另外一些情况下，期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值。

> 相应地，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由。

```java
比如，假设期约向服务器发送一个 HTTP 请求并预定会返回一个 JSON。如果请求返回范围在 200~299 的状态码，则足以让期约的状态変为兑现。此时期约内部就可以收到一个 JSON 字符串。类似地，如果请求返回的状态码不在 200~299 这个范围内，那么就会把期约状态切换为拒绝。此时拒绝的理由可能是一个 Eror 对象，包含着 HTTP 状态码及相关错误消息。
```

为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的 **内部值（value）**。类似地，每个期约只要状态切换为拒绝，就会有一个私有的 **内部理由（reason）**。

> 无论是值还是理由，都是包含原始值或对象的不可修改的引用。
>
> 二者都是可选的，而且默认值为 undefined。
>
> 在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由



<h5><font color = "green">3. 通过执行函数控制期约状态</font></h5>

由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责

- 初始化期约的异步行为
- 控制状态的最终转换

其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve（）和 reject（）

- 调用 resolve（）会把状态切换为兑现
- 调用 reject（）会把状态切换为拒绝。另外，调用 reject（）也会抛出错误（后面会讨论这个错误）

```javascript
let p1 = new Promise((resolve, reject) => resolve());
setTimeout(console.log, 0, p1);

let p2 = new Promise((resolve, reject) => reject());
setTimeout(console.log, 0, p2);
```

在前面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态。

> 这里的关键在于，执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。

```javascript
// 通过下面的例子可以看出上面代码的执行顺序
new Promise(() => setTimeout(console.log, 0, 'executor'));
setTimeout(console.log, 0, 'promise initialized');

// 添加 settimeout 可以推迟切换状态
let p = new Promise((resolve, reject) => setTimeout (resolve, 1000));
setTimeout(console.log, 0, p);

// 无论 resolve() 和 reject() 中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败
let p = new Promise((resolve, reject) => {
    resolve();
    reject();   // 没有效果
});

setTimeout(console.log, 0, p);
```

为避免期约卡在待定状态，可以添加一个定时退出功能。比如，可以通过 settimeout 设置一个 10 秒钟后无论如何都会拒绝期约的回调。

```javascript
let p = new Promise((resolve, reject) => {
    setTimeout(reject, 10000);
});

setTimeout(console.log, 0, p);
setTimeout(console.log, 1100, p);
```

因为期约的状态只能改变一次，所以这里的超时拒绝逻辑中可以放心地设置让期约处于待定状态的最长时间。如果执行器中的代码在超时之前已经解决或拒绝，那么超时回调再尝试拒绝也会静默失败。



<h5><font color = "green"><b>4. Promise.resolve() </b></font></h5>

期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用  Promise.resolve（）静态方法，可以实例化一个解决的期约。下面两个期约实例实际上是一样的

```javascript
let p1 = new Promise((resolve, reject) => resolve());
let p2 = Promise.resolve();
```

这个解决的期约的值对应着传给 Promi se. Resolve（）的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约

```javascript
setTimeout(console.log, 0, Promise.resolve());
setTimeout(console.log, 0, Promise.resolve(3));

setTimeout(console.log, 0, Promise.resolve(4, 5, 6));
```

对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此  Promise. Resolve（）可以说是一个幂等方法，如下所示

```javascript
let p = Promise.resolve(7);
setTimeout(console.log, 0, p == Promise.resolve(p));
setTimeout(console.log, 0, p == Promise.resolve(Promise.resolve(p)));

// 这个幂等性会保留传人期约的状态
let p = new Promise(() => {});

setTimeout(console.log, 0, p);
setTimeout(console.log, 0, Promise.resolve(p));

setTimeout(console.log, 0, p === Promise.resolve(p));

// 注意，这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为
let p = Promise.resolve(new Error('foo'));
setTimeout(console.log, 0, p);
```



<h5><font color = "green"><b>5. Promise.reject() </b></font></h5>

与 Promise.resolve() 类似，Promise.reject() 会实例化一个拒绝的期约并抛出一个异步错误

> （这个错误不能通过 try/catch 捕获，而只能通过拒绝处理程序捕获）
>
> 下面的两个期约实例实际上是一样的

```javascript
let p1 = new Promise((resolve, reject) => reject());
let p2 = Promise.reject();
// 这个拒绝的期约的理由就是传给 Promi se. Re] ect（）的第一个参数。这个参数也会传给后续的拒绝处理程序:

let p = Promise.reject(3);
setTimeout(console.log, 0, p);

p.then(null, (e) => setTimeout(console.log, 0, e));
```

关键在于，Promise.reject（）并没有照搬 Promise.resolve() 的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由

```javascript
setTimeout(console.log, 0, Promise.reject(Promise.resolve)); 
//Promise { <rejected> [Function: resolve] }
```



<h5><font color = "green"><b>6. 同步/异步执行的二元性 </b></font></h5>

Promise 的设计很大程度上会导致一种完全不同于 Javascript F 的计算模式。下面的例子完美地展示了这一点，其中包含了两种模式下抛出错误的情形

```javascript
try {
    throw new Error('foo');
} catch (e) {
    console.log(e);
}

try {
    Promise.reject(new Error('bar'));
} catch (e) {
    console.log(e);
}
```

第一个 try/ catch 抛出并捕获了错误，第二个 try/catch 抛出错误却没有捕获到。

> 乍一看这可能有点违反直觉，因为代码中确实是同步创建了一个拒绝的期约实例，而这个实例也抛出了包含拒绝理由的错误

这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。

从这里就可以看出期约真正的异步特性：

> ⚠️ 它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。

在前面的例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try/catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构更具体地说，就是期约的方法



<h3><font color = "blue">11.2.3 期约的实例方法 </font></h3>

期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。

<h5><font color = "green"><b>1. 实现 Thenable 接口 </b></font></h5>

在 ECMAScript 暴露的异步结构中，任何对象都有一个 then() 方法。这个方法被认为实现了  Thenable 接口。下面的例子展示了实现这一接口的最简单的类：

```javascript
class MyThenable {
    then() {}
}
```

ECMAScript 的 Promise 类型实现了 Thenable 接口。这个简化的接口跟 Typescript 或其他包中的接口或类型定义不同，它们都设定了 Thenable 接口更具体的形式。

> 注意:本章后面再介绍异步函数时还会再谈到 Tenable 接口的用途和目的。



<h5><font color = "green"><b>2. Promise.prototype.then() </b></font></h5>

Promise. prototype.then() 是为期约实例添加处理程序的主要方法。这个 then() 方法接收最多两个参数：

- onResolved 处理程序
- onRejected 处理程序

这两个参数都是可选的，如果提供的话则会在期约分别进入“兑现”和“拒绝”状态时执行

```javascript
function onResolved(id) {
    setTimeout(console.log, 0, id, 'resolved');
}
function onRejected(id) {
    setTimeout(console.log, 0, id, 'rejected');
}

let p1 = new Promise((resolve, reject) => setTimeout(resolve, 3000));
let p2 = new Promise((resolve, reject) => setTimeout(reject, 3000));

p1.then(() => onResolved('p1'),
        () => onRejected('p1'));
p2.then(() => onResolved('p2'),
        () => onRejected('p2'));

// 因为期约只能转换为最终状态一次，所以这两个操作一定是互斥的。
```



<h5><font color = "green"><b>3. Promise.prototype.catch() </b></font></h5>



<h5><font color = "green"><b>4. Promise.prototype.finally() </b></font></h5>



<h5><font color = "green"><b>5. 非重入期约方法 </b></font></h5>



<h5><font color = "green"><b>6. 邻近处理程序的执行顺序 </b></font></h5>



<h5><font color = "green"><b>7. 传递解决值和拒绝理由 </b></font></h5>



<h5><font color = "green"><b>8. 拒绝期约与拒绝错误处理 </b></font></h5>



<h3><font color = "blue">11.2.4 期约连锁与期约合成 </font></h3>



<h5><font color = "green"><b>1. 期约连锁 </b></font></h5>



<h5><font color = "green"><b>2. 期约图 </b></font></h5>



<h5><font color = "green"><b>3. Promise.All() 和 Promise.race() </b></font></h5>



<h5><font color = "green"><b>4. 串行期约合成 </b></font></h5>



<h3><font color = "blue">11.2.5 期约扩展 </font></h3>



<h5><font color = "green"><b>1. 期约取消 </b></font></h5>

<h5><font color = "green"><b>2. 期约进度通知 </b></font></h5>



<h1 align="center"><font color = 'red'>11.3 异步函数 </font></h1>
<h3 align="center"></h3>

<h3><font color = "blue">11.3.1 异步函数 </font></h3>

<h3><font color = "blue">11.3.2 停止和恢复执行 </font></h3>

<h3><font color = "blue">11.3.3 异步函数策略 </font></h3>



<h1 align="center"><font color = 'red'>11.4 总结 </font></h1>
<h3 align="center"></h3>