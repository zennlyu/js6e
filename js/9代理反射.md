<h1 align="center"><font color = 'red'>9.1 代理基础 </font></h1>
<h3 align="center"></h3>



<h3><font color = "blue">9.1.0 简介 </font></h3>

<h3><font color = "blue">9.1.1 创建空代理 </font></h3>

<h3><font color = "blue">9.1.2 定义捕获器 </font></h3>

<h3><font color = "blue">9.1.3 捕获器参数和反射 API</font></h3>

<h3><font color = "blue">9.1.4 捕获器不变式 </font></h3>

<h1 align="center"><font color = 'red'>10.2 函数名 </font></h1>
<h3 align="center"></h3>

因为函数名就是指向函数的指针，所以它们跟其他包含对象指针的变量具有相同的行为。这意味着个函数可以有多个名称

> 注意，使用不带括号的函数名会访问函数指针，而不会执行函数

ECMAScript6 的所有函数对象都会暴露一个只读的 name 属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串。如果它是使用 Function 构造函数创建的，则会标识成 “anonymous"

如果函数是一个获取函数、设置函数，或者使用 bind() 实例化，那么标识符前面会加上一个前缀：



<h1 align="center"><font color = 'red'>10.3 理解参数 </font></h1>
<h3 align="center"></h3>

ECMAScript  函数的参数跟大多数其他语言不同。ECMAScript 函数既不关心传入的参数个数，也不关心这些参数的数据类型。

> 定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错。

之所以会这样，主要是因为 ECMAScript 函数的参数在内部表现为一个数组。

> 函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。如果数组中什么也没有，那没问题；如果数组的元素超出了要求，那也没问题。

事实上，在使用 function 关键字定义（非箭头）函数时，可以在函数内部访问 arguments 对象，从中取得传进来的每个参数值。

arguments 对象是一个类数组对象（但不是 Array 的实例），因此可以使用中括号语法访问其中的元素（第一个参数是 arguments [0]，第二个参数是 arguments [1]）。而要确定传进来多少个参数，可以访问 arguments.length 属性。

> 可以通过 arguments [0] 取得相同的参数值。因此，把函数重写成不声明参数也可以：

在重写后的代码中，没有命名参数。name 和 message 参数都不见了，但函数照样可以调用。这就表明，ECMAScript 函数的参数只是为了方便才写出来的，并不是必须写出来的。与其他语言不同，在  ECMAScript 中的命名参数不会创建让之后的调用必须匹配的函数签名。这是因为根本不存在验证命名参数的机制。

也可以通过 arguments 对象的 length 属性检査传入的参数个数。下面的例子展示了在每调用函数时，都会打印出传入的参数个数：

```javascript
console.log(arguments.length)
```

还有一个必须理解的重要方面，那就是 arguments 对象可以跟命名参数一起使用，比如：

Arguments 对象的另一个有意思的地方就是，它的值始终会与对应的命名参数同步。来看下面的例子：

> 并不意味着都访问同一个内存地址，他们在内存中还是分开的，只不过会保持同步

另外还要记住一点：如果只传了一个参数，然后把 arguments [1 设置为某个值，那么这个值并不会反映到第二个命名参数。这是因为 arguments 对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的。

对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是 undefined。这就类似于定义了变量而没有初始化。比如，如果只给 doadd）传了一个参数，那么 num2 的值就是 undefined。

严格模式下，arguments 会有一些变化。首先，像前面那样给 arguments [1] 赋值不会再影响 num2 的值。就算把 arguments [1] 设置为 10, num2 的值仍然还是传的值。其次，在函数中尝试重写  arguments 对象会导致语法错误。（代码也不会执行）



<h3><font color = "blue">箭头函数中的参数 </font></h3>

如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 arguments 关键字访问，而只能通过定义的命名参数访问。

虽然箭头函数中没有 arguments 对象，但可以在包装函数中把它提供给箭头函数。

注意⚠️： Ecmascript 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。

<h1 align="center"><font color = 'red'>10.4 没有重载 </font></h1>
<h3 align="center"></h3>

ECMAScript 函数不能像传统编程那样重载。在其他语言比如 Java 中，一个函数可以有两个定义，只要签名（接收参数的类型和数量）不同就行。如前所述，Ecmascript 函数没有签名，因为参数是由包含零个或多个值的数组表示的。没有函数签名，自然也就没有重载。

如果在 Ecmascript 中定义了两个同名函数，则后定义的会覆盖先定义的。来看下面的例子：

前面也提到过，可以通过检査参数的类型和数量，然后分别执行不同的逻辑来模拟函数重载。

把函数名当成指针也有助于理解为什么 ECMASCRIPT 没有函数重载。

<h1 align="center"><font color = 'red'>10.5 默认参数值 </font></h1>
<h3 align="center"></h3>

在 ECMAScript 5.1 及以前，实现默认参数的一种常用方式就是检测某个参数是否等于 undefined，如果是则意味着没有传这个参数，那就给它赋一个值

Ecmascript 6 之后就不用这么麻烦了，因为它支持显式定义默认参数了。下面就是与前面代码等价的 ES6 写法，只要在函数定义中的参数后面用=就可以为参数赋一个默认值

给参数传 undefined 相当于没有传值，不过这样可以利用多个独立的默认值：

在使用默认参数时，arguments 对象的值不反映参数的默认值，只反映传给函数的参数。当然，跟 ES5 严格模式一样，修改命名参数也不会影响 arguments 对象，它始终以调用函数时传的值为准：

<h1 align="center"><font color = 'red'>10.6 参数扩展与收集 </font></h1>
<h3 align="center"></h3>

<h1 align="center"><font color = 'red'>10.7 函数声明与函数表达式 </font></h1>
<h3 align="center"></h3>

<h1 align="center"><font color = 'red'>10.8 函数作为值 </font></h1>
<h3 align="center"></h3>

<h1 align="center"><font color = 'red'>10.9 函数內部 </font></h1>
<h3 align="center"></h3>

