<h1 align="center"><font color = 'red'>6.1 Object </font></h1>
<h3 align="center"></h3>

本章主要内容为

- 对象
- 数组和定型数组
- Map，WeakMap，Set 以及 WeakSet 类型

Object 实例没有多少功能，但是很适合存储和应用程序间交换数据

Object 的实例创建有两种方式

- new 操作符
- Object 构造函数
- ⚠️对象字面量表示法（object literal）
  - 也可以定义一个只有默认属性和方法的对象 {}
  - 有封装数据的感觉，属性一目了然，大规模应用

属性的存储有以下方法

- 点语法（首选）
- 中括号存取
  - 优势是可以通过变量访问属性

<h1 align="center"><font color = 'red'>6.2 Array </font></h1>

和其他语言不通

- 数组中每个槽位可以存储任意类型的数据

- ECMAScript 数组也是动态大小的，会随着数据添加而自动增长

<h4><font color = "blue">6.2.1 创建数组</font></h4>

创建数组的方式：

- Array 构造函数
- 数组字面量 array literal

Array 构造函数中有两个创建数组的静态方法

- from() —— 将类数组结构转换为数组实例

```javascript
// 字符串会被拆分为单字符数组
console.log(Array.from("Matt"));

// 可以使用 from() 将集合和映射转换为一个新数组
const m = new Map().set(1,2).set(3,4);

const s = new Set().add(1).add(2).add(3).add(4);

console.log(Array.from(m));
console.log(Array.from(s));

// 可以对现有数组执行浅复制
const a1 = [1,2,3,4];
const a2 = Array.from(a1);

console.log(a1);
console.log(a1 === a2);

// 可以使用任何可迭代对象
const iter = {
    *[Symbol.iterator]() {
        yield 1;
        yield 2;
        yield 3;
        yield 4;
    }
};

console.log(Array.from(iter));

// arguments 对象可以被轻松地转换为数组
function getArgsArray() {
    return Array.from(arguments);
}

// from() 也能转换带有必要属性的自定义对象
const arrayLikeObject = {
    0:1,
    1:2,
    2:3,
    3:4,
    length:4
};

console.log(Array.from(arrayLikeObject))
/***
[ 'M', 'a', 't', 't' ]
[ [ 1, 2 ], [ 3, 4 ] ]
[ 1, 2, 3, 4 ]
[ 1, 2, 3, 4 ]
false
[ 1, 2, 3, 4 ]
[ 1, 2, 3, 4 ]
***/
```

From 还可以接收第二个可选的映射函数参数。该函数可以直接增强新数组的值，而无需像调用 Array.from().map() 那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中 this 的值。但该重写的 this 不适用于箭头函数

```javascript
const a1 = [1, 2, 3, 4];
const a2 = Array.from(a1, x => x**2);
const a3 = Array.from(a1, function(x) {return x**this.exponent}, {exponent:2});
console.log(a2);
console.log(a3);
```

- of()      —— 用于将一组参数转换为数组实例

  - Array.of() 可以把一组参数转换为数组实例。
  - 该方法用于替代在 ES6 之前常用的 Array.prototype.slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法

  ```javascript
  console.log(Array.of(1, 2, 3, 4));
  console.log(Array.of(undefined))
  ```

  

<h4><font color = "blue">6.2.2 数组空位</font></h4>

使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。

ECMAScript 会将逗号之间相应索引位置的值当成空位，ES6 规范重新定义了该如何处理这些空位。

创建一个空位数组：

```javascript
const options = [,,,,,]; // 创建包含 5 个元素的数组
console.log(options.length); // 5 
console.log(options); // [,,,,,] // [ <5 empty items> ]
```

ES6 新增的方法和迭代器与早期 Ecmascript 版本中存在的方法行为不同。ES6 新增方法普遍将这些空位当成存在的元素，只不过值为 undefined

```javascript
const options = [1,,,,5];

for (const option of options) {
    console.log(option === undefined);
}
// false
// true
// true
// true
// false

const a = Array.from([,,,]); // 使用 ES6 的 Array.from()创建的包含3个空位的数组
for (const val of a) {
  console.log(val === undefined);
}
// true
// true
// true
console.log(Array.of(...[,,,])); // [undefined, undefined, undefined]
for (const [index, value] of options.entries()) {
  console.log(value);
}
// 1
// undefined
// undefined
// undefined
// 5
```

ES6 之前的方法则会忽略这个空位，但具体的行为也会因方法而异

```javascript
const options = [1,,,,5];
// map() 会跳过空位置
console.log(options.map(() => 6));  // [6, undefined, undefined, undefined, 6]
// join()  视空位置为空字符串
console.log(options.join('-'));     // "1----5"
```

注意⚠️：由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用 undefined 值代替。



<h4><font color = "blue">6.2.3 数组索引</font></h4>

要取得或设置数组的值，需要使用中括号并提供相应值的数字索引

length 不是只读的，可以借此调整元素，也可以方便的向数组末尾添加元素

注意⚠️：数组最多可以包含 4294967295 个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，则会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本运行时间过长的错误。

<h4><font color = "blue">6.2.4 检测数组</font></h4>

一个经典的 ECMAScript 问题是判断一个对象是不是数组。

- 在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符就足矣

  ```javascript
  if (value instanceof Array) {
      // 操作数组
  }
  ```

  - 使用 instanceof 的问题是假定只有一个全局执行上下文。

    - 如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。
    - 如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。

  - 为解决这个问题，ECMAScript：提供了 Array.isArray() 方法。

    - 这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的

      ```javascript
      if (Array.isArray(value)) {
          // 操作数组
      }
      ```

<h4><font color = "blue">6.2.5 迭代器方法</font></h4>

在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：

- keys()
  - keys()返回数组索引的迭代器，
- values()
  - values()返回数组元素的迭代器
- entries()
  - entries ()返回 索引/值对的迭代器

```javascript
const a = ["foo","bar","baz","qux"];
// 因为这些方法都返回选代器，所以可以将它们的内容
// 通过 Array.from（）直接转换为数组实例
const aKeys = Array.from(a.keys());
const aValues = Array.from(a.values()); 
const aEntries = Array.from(a.entries());
console.log(aKeys); // [0, 1, 2, 3]
console.log(aValues); // ["foo", "bar", "baz", "qux"] 
console.log(aEntries); // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]
```

使用ES6的解构可以非常容易地在循环中拆分键/值对

```javascript
const a = ["foo", "bar", "baz", "qux"];
for (const [idx, element] of a.entries()) {
    console.log(idx);
    console.log(element);
}
// 0
// foo
// 1
// bar
// 2
// baz
// 3
// qux
```

注意虽然这些方法是 ES6 规范定义的，但在 2017 年底的时候仍有浏览器没有实现它们。

<h4><font color = "blue">6.2.6 复制和填充方法</font></h4>

ES6 新增了两个方法：

- 批量复制方法 copywithin (）

- 填充数组方法 fill()

这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。

使用  fill() 方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算也可以将负索引想象成数组长度加上它得到的一个正索引

```javascript
const zeroes = [0, 0, 0, 0, 0];
// 用 5 填充整个数组
zeroes.fill(5);
console.log(zeroes); // [5, 5, 5, 5, 5] 
zeroes.fill(0); // 重置
// 用 6 填充索引大于等于 3 的元素
zeroes.fill(6, 3);
console.log(zeroes); // [0, 0, 0, 6, 6] 
zeroes.fill(0); // 􏳅􏼈
// 用 7 填充索引大于等于 1 且小于 3 的元素
zeroes.fill(7, 1, 3); 
console.log(zeroes); // [0, 7, 7, 0, 0]; 
zeroes.fill(0); // 􏳅􏼈
// 用 8 填充索引大于等于 1 且小于 4 的元素
// (-4 + zeroes.length = 1)
// (-1 + zeroes.length = 4) 
zeroes.fill(8, -4, -1); 
console.log(zeroes); // [0, 8, 8, 8, 0];
```

fill() 静默忽略超出数组边界、零长度及方向相反的索引范围

与fill() 不同，copywithin() 会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与 fill() 使用同样的计算方法

```javascript
let ints,reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();
// 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置
// 在源索引或目标索引到达数组边界时停止
ints.copyWithin(5);
console.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
reset();

// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置
ints.copyWithin(0, 5);
console.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]
reset();

// 从 ints 中复制索引 0 开始到索引 3 结束的内容
// 插入到索引 4 开始的位置
ints.copyWithin(4, 0, 3);
alert(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] 
reset();
// Javascript 引擎在插值前会完整复制范围内的值
// 因此复制期间不存在重写的风险
ints.copyWithin(2, 0, 6);
alert(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] 
reset();
// 支持负索引值，与 fill（）相对于数组末尾计算正向索引的过程是一样的
ints.copyWithin(-4, -7, -3);
alert(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]
```

copywithin() 静默忽略超出数组边界、零长度及方向相反的索引范围

```javascript
let ints,reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();
// 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置
// 在源索引或目标索引到达数组边界时停止
ints.copyWithin(5);
console.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
reset();

// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置
ints.copyWithin(0, 5);
console.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]
reset();

// 从 ints 中复制索引 0 开始到索引 3 结束的内容
// 插入到索引 4 开始的位置
ints.copyWithin(4, 0, 3);
console.log(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] 
reset();
// Javascript 引擎在插值前会完整复制范围内的值
// 因此复制期间不存在重写的风险
ints.copyWithin(2, 0, 6);
console.log(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] 
reset();
// 支持负索引值，与 fill（）相对于数组末尾计算正向索引的过程是一样的
ints.copyWithin(-4, -7, -3);
console.log(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]
```

copywithin（）静默忽略超出数组边界、零长度及方向相反的索引范围

```javascript
let ints,reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();
// 索引过低，忽略
ints.copyWithin(1, -15, -12);
console.log(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset()
// 索引过高，忽略
ints.copyWithin(1, 12, 15);
console.log(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();
// 索引反向，忽略
ints.copyWithin(2, 4, 2);
console.log(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();
// 索引部分可用，复制、填充可用部分
ints.copyWithin(4, 7, 10)
console.log(ints); // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];
```

<h4><font color = "blue">6.2.7 转换方法</font></h4>

<h4><font color = "blue">6.2.8 栈方法</font></h4>

<h4><font color = "blue">6.2.9 队列方法</font></h4>

<h4><font color = "blue">6.2.10 排序方法</font></h4>

<h4><font color = "blue">6.2.11 操作方法</font></h4>

<h4><font color = "blue">6.2.12 搜索和位置方法</font></h4>

<h4><font color = "blue">6.2.13 迭代方法</font></h4>

<h4><font color = "blue">6.2.14 归并方法</font></h4>

<h1 align="center"><font color = 'red'>6.3 定型数组 </font></h1>

`typed array` 新增 `ECMAScript` 结构，目的是提升向原生库传输数据的效率。

`js` 实际并无 `TypedArray` 类型，which 其实是一种特殊的包含数值类型的数组

<h4><font color = "blue">6.3.1 历史 & 痛点</font></h4>

开发 `Javascript API` 以便充分利用 `3D` 图形和 `GPU` 加速，以便在 `<canvas>` 元素上渲染复杂的图形

- `WebGL`: 因为 `JavaScript` 数组和原生数组之间不匹配，出现性能问题。

- 解决
  - `Mozilla` 为此实现了 `CanvasFloatArray`，一个提供 `Javascrip` 接口，C语言风格的浮点值数组，`Javascrip` 运行时使用该类型可分配、读取和写入数组，可以直接传给底层图形驱动程序 `API`，也可以直接从底层获取到。
  - `CanvasFloatArray` 变成了 `Float32Array`, 即 `TypedArray`可用的第一个“类型”

<h4><font color = "blue">6.3.2 ArrayBuffer() 介绍</font></h4>

- `Float32Array` 实际上是一种 "视图"，允许运行时访问名为  `ArrayBuffer` 的预分配内存。

- `ArrayBuffer` 是所有定型数组和视图引用的基本单位

- `ArrayBuffer` 是一个普通的 `Javascript` 构造函数，可以用于在内存中分配特定数量的字节空间

```js
const buf = new ArrayBuffer(16);// 在内存中分配 16 字节
console.log(buf.byteLength)		// 16
```

-  `ArrayBuffer` 一经创建不可调整大小，但可以使用 `slice()` 复制或全部部分分配至一个新的实例

```js
const buf1 = new ArrayBuffer(16);
const buf2 = buf1.slice(4, 12)
console.log(buf2.byteLength)
```

-  `ArrayBuffer` 类似于 `C++` 的 `malloc()` 函数，区别在于：
   - 分配失败
     - `malloc()`在分配失败时会返回一个 `null` 指针
     - `ArrayBuffer` 在分配失败时会抛出错误
   - 利用虚拟内存
     - `malloc()` 可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。
     - `ArrayBuffer`  分配的内存不能超过 `Number.MAX_SAFE_INTEGER(2*53-1) `字节
   - 调用成功
     - `malloc()` 调用成功不会初始化实际地址
     - 声明 `ArrayBuffer` 会将所有二进制初始化为 0
   - 堆内存
     - 通过 `malloc()` 分配的堆内存除非调用 `free()`或程序退出，否则系统不能再使用。
     - 通过 `ArrayBuffer` 分配的堆内存可以被当成垃圾回收，不用手动释放。
-  不能仅通过对 `ArrayBuffer`  的引用就读取或写入其内容。
   -  要读取或写 `ArrayBuffer` ，就必须通过视图。
   -  视图有不同的类型，但引用的都是 `ArrayBuffer`  中存储的二进制数据。

<h4><font color = "blue">6.3.3 DataView</font></h4>

- 第一种允许读写 `ArrayBuffer` 的视图。
  - 专为文件 I/O 和网络 I/O 设计，`API` 支持对缓冲数据的高度控制
  - 代價是性能稍差

- 实例化的时间和契机

  - 必须在对已有的 `ArrayBuffer` 读取或写人时才能创建 `DataView` 实例。
  - 这个实例可以使用全部或部分 `ArrayBuffer` ，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。

  ```javascript
  const buf = new ArrayBuffer(16);
  
  // Dataview 默认使用整个 ArrayBuffer
  const fullDataView = new DataView(buf);
  console.log(fullDataView.byteOffset); // 0 
  console.log(fullDataView.byteLength); // 16 
  console.log(fullDataView.buffer === buf); // true
  
  // 构造函数接收一个可选的字节偏移量和字节长度
  //      byteoffset=0 表示视图从缓冲起点开始  
  //      bytelength=8 限制视图为前 8 个字节
  const firstHalfDataView = new DataView(buf, 0, 8);
  console.log(firstHalfDataView.byteOffset); // 0
  console.log(firstHalfDataView.byteLength); // 8
  console.log(firstHalfDataView.buffer === buf); // true
  
  // 如果不指定，则 Dataview 会使用剩余的缓冲
  //      byteoffset=8 表示视图从缓冲的第 9 个字节开始
  //      bytelength 未指定，默认为剩余缓冲
  const secondHalfDataView = new DataView(buf, 8);
  console.log(secondHalfDataView.byteOffset); // 8
  console.log(secondHalfDataView.byteLength);      // 8
  console.log(secondHalfDataView.buffer === buf);  // true
  ```

- 要通过 `Dataview` 读取缓冲，还需要几个组件

  > - 首先是要读或写的字节偏移量。可以看成 `Dataview` 中的某种“地址”。
  > - `Dataview` 应使用 `ElementType` 来实现 ` Javascript` 的 `Number` 类型到缓冲内二进制格式的转换
  > - 最后是内存中值的字节序。默认为大端字节序。

1. `ElementType`
2. 字节序
3. 边界情形

<h4><font color = "blue">6.3.4 定型数组</font></h4>

1. 定型数组行为
2. 合并，复制，修改 `定性数组`
3. 上溢和下溢

<h1 align="center"><font color = 'red'>6.4 Map </font></h1>

曾经的 `Javascript` 实现键值对存储可以用 `Object` ，使用对象属性 - 键，属性 - 引用值

Map：真正的键值存储机制

<h4><font color = "blue">6.4.1 基本 API</font></h4>

<h4><font color = "blue">6.4.2 顺序与迭代</font></h4>

<h4><font color = "blue">6.4.3 选择 object 还是 Map</font></h4>

1. 内存占用
2. 插入性能
3. 查找速度
4. 删除性能

<h1 align="center"><font color = 'red'>6.5 WeakMap </font></h1>

<h4><font color = "blue">6.5.1 基本 API</font></h4>

