<h1 align="center"><font color = 'red'>6.1 Object </font></h1>
<h3 align="center"></h3>

本章主要内容为

- 对象
- 数组和定型数组
- Map，WeakMap，Set 以及 WeakSet 类型

Object 实例没有多少功能，但是很适合存储和应用程序间交换数据

Object 的实例创建有两种方式

- new 操作符
- Object 构造函数
- ⚠️对象字面量表示法（object literal）
  - 也可以定义一个只有默认属性和方法的对象 {}
  - 有封装数据的感觉，属性一目了然，大规模应用

属性的存储有以下方法

- 点语法（首选）
- 中括号存取
  - 优势是可以通过变量访问属性

<h1 align="center"><font color = 'red'>6.2 Array </font></h1>

和其他语言不通

- 数组中每个槽位可以存储任意类型的数据

- ECMAScript 数组也是动态大小的，会随着数据添加而自动增长

<h4><font color = "blue">6.2.1 创建数组</font></h4>

创建数组的方式：

- Array 构造函数
- 数组字面量 array literal

Array 构造函数中有两个创建数组的静态方法

- from() —— 将类数组结构转换为数组实例

```javascript
// 字符串会被拆分为单字符数组
console.log(Array.from("Matt"));

// 可以使用 from() 将集合和映射转换为一个新数组
const m = new Map().set(1,2).set(3,4);

const s = new Set().add(1).add(2).add(3).add(4);

console.log(Array.from(m));
console.log(Array.from(s));

// 可以对现有数组执行浅复制
const a1 = [1,2,3,4];
const a2 = Array.from(a1);

console.log(a1);
console.log(a1 === a2);

// 可以使用任何可迭代对象
const iter = {
    *[Symbol.iterator]() {
        yield 1;
        yield 2;
        yield 3;
        yield 4;
    }
};

console.log(Array.from(iter));

// arguments 对象可以被轻松地转换为数组
function getArgsArray() {
    return Array.from(arguments);
}

// from() 也能转换带有必要属性的自定义对象
const arrayLikeObject = {
    0:1,
    1:2,
    2:3,
    3:4,
    length:4
};

console.log(Array.from(arrayLikeObject))
/***
[ 'M', 'a', 't', 't' ]
[ [ 1, 2 ], [ 3, 4 ] ]
[ 1, 2, 3, 4 ]
[ 1, 2, 3, 4 ]
false
[ 1, 2, 3, 4 ]
[ 1, 2, 3, 4 ]
***/
```

From 还可以接收第二个可选的映射函数参数。该函数可以直接增强新数组的值，而无需像调用 Array.from().map() 那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中 this 的值。但该重写的 this 不适用于箭头函数

```javascript
const a1 = [1, 2, 3, 4];
const a2 = Array.from(a1, x => x**2);
const a3 = Array.from(a1, function(x) {return x**this.exponent}, {exponent:2});
console.log(a2);
console.log(a3);
```

- of()      —— 用于将一组参数转换为数组实例

  - Array.of() 可以把一组参数转换为数组实例。
  - 该方法用于替代在 ES6 之前常用的 Array.prototype.slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法

  ```javascript
  console.log(Array.of(1, 2, 3, 4));
  console.log(Array.of(undefined))
  ```

  

<h4><font color = "blue">6.2.2 数组空位</font></h4>

使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。

ECMAScript 会将逗号之间相应索引位置的值当成空位，ES6 规范重新定义了该如何处理这些空位。

创建一个空位数组：

```javascript
const options = [,,,,,]; // 创建包含 5 个元素的数组
console.log(options.length); // 5 
console.log(options); // [,,,,,] // [ <5 empty items> ]
```

ES6 新增的方法和迭代器与早期 Ecmascript 版本中存在的方法行为不同。ES6 新增方法普遍将这些空位当成存在的元素，只不过值为 undefined

```javascript
const options = [1,,,,5];

for (const option of options) {
    console.log(option === undefined);
}
// false
// true
// true
// true
// false

const a = Array.from([,,,]); // 使用 ES6 的 Array.from()创建的包含3个空位的数组
for (const val of a) {
  console.log(val === undefined);
}
// true
// true
// true
console.log(Array.of(...[,,,])); // [undefined, undefined, undefined]
for (const [index, value] of options.entries()) {
  console.log(value);
}
// 1
// undefined
// undefined
// undefined
// 5
```

ES6 之前的方法则会忽略这个空位，但具体的行为也会因方法而异

```javascript
const options = [1,,,,5];
// map() 会跳过空位置
console.log(options.map(() => 6));  // [6, undefined, undefined, undefined, 6]
// join()  视空位置为空字符串
console.log(options.join('-'));     // "1----5"
```

注意⚠️：由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用 undefined 值代替。



<h4><font color = "blue">6.2.3 数组索引</font></h4>

要取得或设置数组的值，需要使用中括号并提供相应值的数字索引

length 不是只读的，可以借此调整元素，也可以方便的向数组末尾添加元素

注意⚠️：数组最多可以包含 4294967295 个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，则会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本运行时间过长的错误。

<h4><font color = "blue">6.2.4 检测数组</font></h4>

一个经典的 ECMAScript 问题是判断一个对象是不是数组。

- 在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符就足矣

  ```javascript
  if (value instanceof Array) {
      // 操作数组
  }
  ```

  - 使用 instanceof 的问题是假定只有一个全局执行上下文。

    - 如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。
    - 如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。

  - 为解决这个问题，ECMAScript：提供了 Array.isArray() 方法。

    - 这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的

      ```javascript
      if (Array.isArray(value)) {
          // 操作数组
      }
      ```

<h4><font color = "blue">6.2.5 迭代器方法</font></h4>

在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：

- keys()
  - keys()返回数组索引的迭代器，
- values()
  - values()返回数组元素的迭代器
- entries()
  - entries ()返回 索引/值对的迭代器

```javascript
const a = ["foo","bar","baz","qux"];
// 因为这些方法都返回选代器，所以可以将它们的内容
// 通过 Array.from（）直接转换为数组实例
const aKeys = Array.from(a.keys());
const aValues = Array.from(a.values()); 
const aEntries = Array.from(a.entries());
console.log(aKeys); // [0, 1, 2, 3]
console.log(aValues); // ["foo", "bar", "baz", "qux"] 
console.log(aEntries); // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]
```

使用ES6的解构可以非常容易地在循环中拆分键/值对

```javascript
const a = ["foo", "bar", "baz", "qux"];
for (const [idx, element] of a.entries()) {
    console.log(idx);
    console.log(element);
}
// 0
// foo
// 1
// bar
// 2
// baz
// 3
// qux
```

注意虽然这些方法是 ES6 规范定义的，但在 2017 年底的时候仍有浏览器没有实现它们。

<h4><font color = "blue">6.2.6 复制和填充方法</font></h4>

ES6 新增了两个方法：

- 批量复制方法 copywithin (）

- 填充数组方法 fill()

这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。

使用  fill() 方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算也可以将负索引想象成数组长度加上它得到的一个正索引

```javascript
const zeroes = [0, 0, 0, 0, 0];
// 用 5 填充整个数组
zeroes.fill(5);
console.log(zeroes); // [5, 5, 5, 5, 5] 
zeroes.fill(0); // 重置
// 用 6 填充索引大于等于 3 的元素
zeroes.fill(6, 3);
console.log(zeroes); // [0, 0, 0, 6, 6] 
zeroes.fill(0); // 􏳅􏼈
// 用 7 填充索引大于等于 1 且小于 3 的元素
zeroes.fill(7, 1, 3); 
console.log(zeroes); // [0, 7, 7, 0, 0]; 
zeroes.fill(0); // 􏳅􏼈
// 用 8 填充索引大于等于 1 且小于 4 的元素
// (-4 + zeroes.length = 1)
// (-1 + zeroes.length = 4) 
zeroes.fill(8, -4, -1); 
console.log(zeroes); // [0, 8, 8, 8, 0];
```

fill() 静默忽略超出数组边界、零长度及方向相反的索引范围

与fill() 不同，copywithin() 会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与 fill() 使用同样的计算方法

```javascript
let ints,reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();
// 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置
// 在源索引或目标索引到达数组边界时停止
ints.copyWithin(5);
console.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
reset();

// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置
ints.copyWithin(0, 5);
console.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]
reset();

// 从 ints 中复制索引 0 开始到索引 3 结束的内容
// 插入到索引 4 开始的位置
ints.copyWithin(4, 0, 3);
alert(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] 
reset();
// Javascript 引擎在插值前会完整复制范围内的值
// 因此复制期间不存在重写的风险
ints.copyWithin(2, 0, 6);
alert(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] 
reset();
// 支持负索引值，与 fill（）相对于数组末尾计算正向索引的过程是一样的
ints.copyWithin(-4, -7, -3);
alert(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]
```

copywithin() 静默忽略超出数组边界、零长度及方向相反的索引范围

```javascript
let ints,reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();
// 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置
// 在源索引或目标索引到达数组边界时停止
ints.copyWithin(5);
console.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
reset();

// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置
ints.copyWithin(0, 5);
console.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]
reset();

// 从 ints 中复制索引 0 开始到索引 3 结束的内容
// 插入到索引 4 开始的位置
ints.copyWithin(4, 0, 3);
console.log(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] 
reset();
// Javascript 引擎在插值前会完整复制范围内的值
// 因此复制期间不存在重写的风险
ints.copyWithin(2, 0, 6);
console.log(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] 
reset();
// 支持负索引值，与 fill（）相对于数组末尾计算正向索引的过程是一样的
ints.copyWithin(-4, -7, -3);
console.log(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]
```

copywithin（）静默忽略超出数组边界、零长度及方向相反的索引范围

```javascript
let ints,reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();
// 索引过低，忽略
ints.copyWithin(1, -15, -12);
console.log(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset()
// 索引过高，忽略
ints.copyWithin(1, 12, 15);
console.log(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();
// 索引反向，忽略
ints.copyWithin(2, 4, 2);
console.log(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();
// 索引部分可用，复制、填充可用部分
ints.copyWithin(4, 7, 10)
console.log(ints); // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];
```

<h4><font color = "blue">6.2.7 转换方法</font></h4>

<h4><font color = "blue">6.2.8 栈方法</font></h4>

<h4><font color = "blue">6.2.9 队列方法</font></h4>

<h4><font color = "blue">6.2.10 排序方法</font></h4>

<h4><font color = "blue">6.2.11 操作方法</font></h4>

<h4><font color = "blue">6.2.12 搜索和位置方法</font></h4>

<h4><font color = "blue">6.2.13 迭代方法</font></h4>

<h4><font color = "blue">6.2.14 归并方法</font></h4>

<h1 align="center"><font color = 'red'>6.3 定型数组 </font></h1>

`typed array` 新增 `ECMAScript` 结构，目的是提升向原生库传输数据的效率。

`js` 实际并无 `TypedArray` 类型，which 其实是一种特殊的包含数值类型的数组

<h4><font color = "blue">6.3.1 历史 & 痛点</font></h4>

开发 `Javascript API` 以便充分利用 `3D` 图形和 `GPU` 加速，以便在 `<canvas>` 元素上渲染复杂的图形

- `WebGL`: 因为 `JavaScript` 数组和原生数组之间不匹配，出现性能问题。

- 解决
  - `Mozilla` 为此实现了 `CanvasFloatArray`，一个提供 `Javascrip` 接口，C语言风格的浮点值数组，`Javascrip` 运行时使用该类型可分配、读取和写入数组，可以直接传给底层图形驱动程序 `API`，也可以直接从底层获取到。
  - `CanvasFloatArray` 变成了 `Float32Array`, 即 `TypedArray`可用的第一个“类型”

<h4><font color = "blue">6.3.2 ArrayBuffer() 介绍</font></h4>

- `Float32Array` 实际上是一种 "视图"，允许运行时访问名为  `ArrayBuffer` 的预分配内存。

- `ArrayBuffer` 是所有定型数组和视图引用的基本单位

- `ArrayBuffer` 是一个普通的 `Javascript` 构造函数，可以用于在内存中分配特定数量的字节空间

```js
const buf = new ArrayBuffer(16);// 在内存中分配 16 字节
console.log(buf.byteLength)		// 16
```

-  `ArrayBuffer` 一经创建不可调整大小，但可以使用 `slice()` 复制或全部部分分配至一个新的实例

```js
const buf1 = new ArrayBuffer(16);
const buf2 = buf1.slice(4, 12)
console.log(buf2.byteLength)
```

-  `ArrayBuffer` 类似于 `C++` 的 `malloc()` 函数，区别在于：
   - 分配失败
     - `malloc()`在分配失败时会返回一个 `null` 指针
     - `ArrayBuffer` 在分配失败时会抛出错误
   - 利用虚拟内存
     - `malloc()` 可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。
     - `ArrayBuffer`  分配的内存不能超过 `Number.MAX_SAFE_INTEGER(2*53-1) `字节
   - 调用成功
     - `malloc()` 调用成功不会初始化实际地址
     - 声明 `ArrayBuffer` 会将所有二进制初始化为 0
   - 堆内存
     - 通过 `malloc()` 分配的堆内存除非调用 `free()`或程序退出，否则系统不能再使用。
     - 通过 `ArrayBuffer` 分配的堆内存可以被当成垃圾回收，不用手动释放。
-  不能仅通过对 `ArrayBuffer`  的引用就读取或写入其内容。
   -  要读取或写 `ArrayBuffer` ，就必须通过视图。
   -  视图有不同的类型，但引用的都是 `ArrayBuffer`  中存储的二进制数据。

<h4><font color = "blue">6.3.3 DataView</font></h4>

- 第一种允许读写 `ArrayBuffer` 的视图。
  - 专为文件 I/O 和网络 I/O 设计，`API` 支持对缓冲数据的高度控制
  - 代價是性能稍差

- 实例化的时间和契机

  - 必须在对已有的 `ArrayBuffer` 读取或写人时才能创建 `DataView` 实例。
  - 这个实例可以使用全部或部分 `ArrayBuffer` ，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。

  ```javascript
  const buf = new ArrayBuffer(16);
  
  // Dataview 默认使用整个 ArrayBuffer
  const fullDataView = new DataView(buf);
  console.log(fullDataView.byteOffset); // 0 
  console.log(fullDataView.byteLength); // 16 
  console.log(fullDataView.buffer === buf); // true
  
  // 构造函数接收一个可选的字节偏移量和字节长度
  //      byteoffset=0 表示视图从缓冲起点开始  
  //      bytelength=8 限制视图为前 8 个字节
  const firstHalfDataView = new DataView(buf, 0, 8);
  console.log(firstHalfDataView.byteOffset); // 0
  console.log(firstHalfDataView.byteLength); // 8
  console.log(firstHalfDataView.buffer === buf); // true
  
  // 如果不指定，则 Dataview 会使用剩余的缓冲
  //      byteoffset=8 表示视图从缓冲的第 9 个字节开始
  //      bytelength 未指定，默认为剩余缓冲
  const secondHalfDataView = new DataView(buf, 8);
  console.log(secondHalfDataView.byteOffset); // 8
  console.log(secondHalfDataView.byteLength);      // 8
  console.log(secondHalfDataView.buffer === buf);  // true
  ```

- 要通过 `Dataview` 读取缓冲，还需要几个组件

  > - 首先是要读或写的字节偏移量。可以看成 `Dataview` 中的某种“地址”。
  > - `Dataview` 应使用 `ElementType` 来实现 ` Javascript` 的 `Number` 类型到缓冲内二进制格式的转换
  > - 最后是内存中值的字节序。默认为大端字节序。

1. ###### `ElementType`

   `Dataview` 对存储在缓冲内的数据类型没有预设。它暴露的 API 强制开发者在读写时指定 `ElementType`，然后 `Dataview` 就会忠实地为读、写而完成相应的转换。

   支持8种不同的 `ElementType`

   `Dataview` 为上表中的每种类型都暴露了 get 和 set 方法，这些方法使用 byteOffset（字节偏移量）定位要读取或写入值的位置。类型是可以互换使用的，如下

   ```javascript
   const buf = new ArrayBuffer(2);
   const view = new DataView(buf);
   
   // 说明整个缓冲确实所有二进制位都是 0 
   // 检査第一个和第二个字符
   console.log(view.getInt8(0)); // 0
   console.log(view.getInt8(1)); // 0
   // 检查整个缓冲
   console.log(view.getInt16(0)); // 0
   
   // 将整个缓冲都设置为 1
   // 255 的二进制表示是 11111111 (2^8-1)
   view.setUint8(0, 255);
   
   // Dataview 会自动将数据转換为特定的 ElementType
   // 255 的十六进制表示是 0xFF
   view.setUint8(1, 0xFF);
   
   // 现在，缓冲里都是 1 了
   // 如果把它当成二补数的有符号整数，则应该是-1
   console.log(view.getInt16(0)); // -1
   ```

2. ###### 字节序

   - 前例中的缓冲有意回避了字节序的问题。

   - “字节序”指的是计算系统维护的一种字节顺序的约定。
   - Dataview 只支持两种约定
     - 大端字节序
       - 大端字节序也称为“网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。
     - 小端字节序
       - 小端字节序正好相反，即最低有效位保存在第一个字节，最高有效位保存在最后一个字节

   Javascript 运行时所在系统的原生字节序决定了如何读取或写入字节，但 Dataview 并不遵守这个约定。对一段内存而言，Dataview 是一个中立接口，它会遵循你指定的字节序。Dataview 的所有 API 方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为 true 即可启用小端字节序

   ```javascript
   // 在内存中分配两个字节并声明一个 Dataview
   const buf = new ArrayBuffer(2);
   const view = new DataView(buf);
   
   // 填充缓冲，让第一位和最后一位都是 1
   view.setUint8(0, 0x80); // 设置最左边的位等于1 
   view.setUint8(1, 0x01); // 设置最右边的位等于1
   
   // 缓冲内容（为方便阅读，人为加了空格）
   // 0×8 0x0 0x0 0x1 
   // 1000 0000 0000 0001
   
   // 按大端字节序读取 Uint16 0x80 是高字节，0x01 是低字节
   // 0x80 是高字节，0x01 是低字节
   // 0x8001 = 2^15+2^0 = 32768 + 1 = 32769
   console.log(view.getUint16(0)); // 32769
   
   // 按小端字节序读取 Uint16
   // 0x01 是高字节，0x80 是低字节
   // 0x8001 = 2^8 + 2^7 = 256 + 128 = 384
   console.log(view.getUint16(0, true)); // 384
   
   // 按大端字节序写入 Uint16
   view.setUint16(0, 0x0004);
   
   // 缓冲内容（为方便阅读，人为加了空格）
   // 0×8 0x0 0x0 0x4
   // 0000 0000 0000 0100
   console.log(view.getUint8(0)); // 0
   console.log(view.getUint8(1)); // 4
   
   // 按小端字节序写入 Uint16
   view.setUint16(0, 0x0002, true);
   
   // 缓冲内容（为方便阅读，人为加了空格）
   // 0x0 0x2 0x0 0x0
   // 0000 0010 0000 0000
   console.log(view.getUint8(0)); // 2
   console.log(view.getUint8(1)); // 0
   ```

   

3. ###### 边界情形

   - Dataview 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 RangeError
   - Dataview 在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为 0。如无法转换，抛出错误

<h4><font color = "blue">6.3.4 定型数组</font></h4>

 定型数组是另一种形式的 `ArrayBuffer` 视图。区别在于，特定于一种 `ElementType` 且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的 API 和更高的性能。设计定型数组的目的就是提高与 WEBGL 等原生库交换二进制数据的效率。由于定型数组的二进制表示对操作系统而言是一种容易使用的格式，Javascript 引擎可以重度优化算术运算按位运算和其他对定型数组的常见操作，因此使用它们速度极快。

创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。另外，通过 `<ElementType>.from()` 和 `<ElementType>.of()` 也可以创建定型数组：

定型数组的构造函数和实例都有一个 BYTES_PER_ ELEMMENT 属性，返回该类型数组中每个元素的大小：

如果定型数组没有用任何值初始化，则其关联的缓冲会以 0 填充：

1. ###### 定型数组行为

2. ###### 合并，复制，修改 `定性数组`

3. ###### 上溢和下溢

<h1 align="center"><font color = 'red'>6.4 Map </font></h1>

曾经的 `Javascript` 实现键值对存储可以用 `Object` ，使用对象属性 - 键，属性 - 引用值

Map 带来了真正的键值存储机制

<h4><font color = "blue">6.4.1 基本 API</font></h4>

- 创建空映射：`const m = new Map()`

- 同时初始化实例：传入可迭代对象

- 初始化之后，可以使用 set() 方法再添加键值对。另外，可以使用 get() 和 has() 进行査询，可以通过 size 属性获取映射中的键值对的数量，还可以使用 delete() 和 clear() 删除值。

  - set() 方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明：

- 与 Object 只能使用数值、字符串或符号作为键不同，Map 可以使用任何 Javascript 数据类型作为键。Map 内部使用 SameValueZero 比较操作（ECMASCRIPT 规范内部定义，语言中不能使用），基本上相当于使用严格对象相等的标准来检査键的匹配性。与 Object 类似，映射的值是没有限制的。

- 与严格相等一样，在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变：

- Samevaluezero 比较也可能导致意想不到的冲突：

  > ⚠️ SameValuezero 是 Ecmascript 规范新的相等性比较算法。关于 Ecmascript 的相等性比较，可以参考 MDN 文档中的文章 “Equality Comparisons and Sameness“

<h4><font color = "blue">6.4.2 顺序与迭代</font></h4>

与 Object 类型的一个主要差异：Map 实例会维护键值对的插人顺序，因此可以根据插入顺序执行迭代操作

映射实例可以提供一个迭代器（Iterator），能以插入顺序生成 [key, vaue] 形式的数组。可以通过 entries() 方法( 或者 Symbol.iterator 属性，它引用 entries() )取得这个迭代器

因为 entries() 是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组

如果不使用迭代器，而是使用回调方式，则可以调用映射的 forEach(callback, opt_thisArg) 方法并传入回调，依次迭代每个键值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this 的值：

keys() 和 values() 分别返回以插人顺序生成键和值的迭代器：

键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份：

<h4><font color = "blue">6.4.3 选择 object 还是 Map</font></h4>

对象和映射之间还是存在显著差别的

##### 1. 内存占用

- Object 和 Map 的工程级实现在不同浏览器间存在明显差异，但存储单个键值对所占用的内存数量都会随键的数量线性增加。
- 给定固定大小的内存，Map 大约可以比 Object 多存储 50% 的键/值对。
- 批量添加或删除键值对则取决于各浏览器对该类型内存分配的工程实现。

##### 2. 插入性能

- Map 一般会稍微快。适合涉及大量插入操作

- 对这两个类型来说，插入速度并不会随着键/值对数量而线性增加

##### 3. 查找速度

- 从大型 Object和Map中査找键/值对的性能差异极小
- 但如只包含少量键值对，Object 有时候速度更快。
  - 在把 Object 当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。
  - 这对 Map 来说是不可能的。
- 对这两个类型而言，査找速度不会随着值对数量增加而线性增加。
- 如代码涉及大量査找操作，某些情况下选择 Object 更好一些

##### 4. 删除性能

- 使用 delete 删除 Object 属性的性能一直以来饱受诟病，仍然如此。
  - 为此出现了一些伪删除对象属性的操作，包括把属性值设置为 undefined 或 null
  - 但很多时候，这都是一种讨厌的或不适宜的折中。
- Map 的 delete() 操作都比插入和査找更快。
- 如果代码涉及大量删除操作，那么毫无疑问应该选择 Map。

<h1 align="center"><font color = 'red'>6.5 WeakMap </font></h1>

<h4><font color = "blue">6.5.1 基本 API</font></h4>

